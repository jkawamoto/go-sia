// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FileInfo file info
// swagger:model FileInfo
type FileInfo struct {

	// indicates the last time the siafile was accessed
	// Format: date-time
	Accesstime strfmt.DateTime `json:"accesstime,omitempty"`

	// true if the file is available for download. Files may be available before they are completely uploaded.
	Available bool `json:"available,omitempty"`

	// indicates the last time the siafile metadata was updated
	// Format: date-time
	Changetime strfmt.DateTime `json:"changetime,omitempty"`

	// indicates the encryption used for the siafile
	Ciphertype string `json:"ciphertype,omitempty"`

	// indicates when the siafile was created
	// Format: date-time
	Createtime strfmt.DateTime `json:"createtime,omitempty"`

	// Block height at which the file ceases availability.
	Expiration int64 `json:"expiration,omitempty"`

	// Size of the file in bytes.
	Filesize int64 `json:"filesize,omitempty"`

	// health is an indication of the amount of redundancy missing where 0 is full redundancy and >1 means the file is not available. The health of the siafile is the health of the worst unstuck chunk.
	Health float64 `json:"health,omitempty"`

	// Path to the local file on disk.
	Localpath string `json:"localpath,omitempty"`

	// the maxhealth is either the health or the stuckhealth of the siafile, whichever is worst
	Maxhealth float64 `json:"maxhealth,omitempty"`

	// maxhealthpercent is the maxhealth converted to be out of 100% to be more easily understood
	Maxhealthpercent float64 `json:"maxhealthpercent,omitempty"`

	// indicates the last time the siafile contents where modified
	// Format: date-time
	Modtime strfmt.DateTime `json:"modtime,omitempty"`

	// indicates the number of stuck chunks in a file. A chunk is stuck if it cannot reach full redundancy
	Numstuckchunks int64 `json:"numstuckchunks,omitempty"`

	// indicates if the source file is found on disk
	Ondisk bool `json:"ondisk,omitempty"`

	// indicates if the siafile is recoverable
	Recoverable bool `json:"recoverable,omitempty"`

	// Average redundancy of the file on the network. Redundancy is calculated by dividing the amount of data uploaded in the file's open contracts by the size of the file. Redundancy does not necessarily correspond to availability. Specifically, a redundancy >= 1 does not indicate the file is available as there could be a chunk of the file with 0 redundancy.
	Redundancy float64 `json:"redundancy,omitempty"`

	// true if the file's contracts will be automatically renewed by the renter.
	Renewing bool `json:"renewing,omitempty"`

	// Path to the file in the renter on the network.
	Siapath string `json:"siapath,omitempty"`

	// a file is stuck if there are any stuck chunks in the file, which means the file cannot reach full redundancy
	Stuck bool `json:"stuck,omitempty"`

	// stuckhealth is the worst health of any of the stuck chunks.
	Stuckhealth float64 `json:"stuckhealth,omitempty"`

	// Total number of bytes successfully uploaded via current file contracts. This number includes padding and rendundancy, so a file with a size of 8192 bytes might be padded to 40 MiB and, with a redundancy of 5, encoded to 200 MiB for upload.
	Uploadedbytes int64 `json:"uploadedbytes,omitempty"`

	// Percentage of the file uploaded, including redundancy. Uploading has completed when uploadprogress is 100. Files may be available for download before upload progress is 100.
	Uploadprogress float64 `json:"uploadprogress,omitempty"`
}

// Validate validates this file info
func (m *FileInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccesstime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChangetime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatetime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModtime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FileInfo) validateAccesstime(formats strfmt.Registry) error {

	if swag.IsZero(m.Accesstime) { // not required
		return nil
	}

	if err := validate.FormatOf("accesstime", "body", "date-time", m.Accesstime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateChangetime(formats strfmt.Registry) error {

	if swag.IsZero(m.Changetime) { // not required
		return nil
	}

	if err := validate.FormatOf("changetime", "body", "date-time", m.Changetime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateCreatetime(formats strfmt.Registry) error {

	if swag.IsZero(m.Createtime) { // not required
		return nil
	}

	if err := validate.FormatOf("createtime", "body", "date-time", m.Createtime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *FileInfo) validateModtime(formats strfmt.Registry) error {

	if swag.IsZero(m.Modtime) { // not required
		return nil
	}

	if err := validate.FormatOf("modtime", "body", "date-time", m.Modtime.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FileInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FileInfo) UnmarshalBinary(b []byte) error {
	var res FileInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
