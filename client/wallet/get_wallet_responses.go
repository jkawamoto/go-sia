// Code generated by go-swagger; DO NOT EDIT.

package wallet

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"

	strfmt "github.com/go-openapi/strfmt"

	models "github.com/jkawamoto/go-sia/models"
)

// GetWalletReader is a Reader for the GetWallet structure.
type GetWalletReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetWalletReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {

	case 200:
		result := NewGetWalletOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil

	default:
		result := NewGetWalletDefault(response.Code())
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		if response.Code()/100 == 2 {
			return result, nil
		}
		return nil, result
	}
}

// NewGetWalletOK creates a GetWalletOK with default headers values
func NewGetWalletOK() *GetWalletOK {
	return &GetWalletOK{}
}

/*GetWalletOK handles this case with default header values.

Successful Response
*/
type GetWalletOK struct {
	Payload *GetWalletOKBody
}

func (o *GetWalletOK) Error() string {
	return fmt.Sprintf("[GET /wallet][%d] getWalletOK  %+v", 200, o.Payload)
}

func (o *GetWalletOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetWalletOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetWalletDefault creates a GetWalletDefault with default headers values
func NewGetWalletDefault(code int) *GetWalletDefault {
	return &GetWalletDefault{
		_statusCode: code,
	}
}

/*GetWalletDefault handles this case with default header values.

Error Response
*/
type GetWalletDefault struct {
	_statusCode int

	Payload *models.StandardError
}

// Code gets the status code for the get wallet default response
func (o *GetWalletDefault) Code() int {
	return o._statusCode
}

func (o *GetWalletDefault) Error() string {
	return fmt.Sprintf("[GET /wallet][%d] GetWallet default  %+v", o._statusCode, o.Payload)
}

func (o *GetWalletDefault) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.StandardError)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*GetWalletOKBody get wallet o k body
swagger:model GetWalletOKBody
*/
type GetWalletOKBody struct {

	// Number of siacoins, in hastings, available to the wallet as of the most recent block in the blockchain.
	Confirmedsiacoinbalance string `json:"confirmedsiacoinbalance,omitempty"`

	// Number of siacoins, in hastings per byte, below which a transaction output cannot be used because the wallet considers it a dust output
	Dustthreshold string `json:"dustthreshold,omitempty"`

	// Indicates whether the wallet has been encrypted or not. If the wallet has not been encrypted, then no data has been generated at all, and the first time the wallet is unlocked, the password given will be used as the password for encrypting all of the data. 'encrypted' will only be set to false if the wallet has never been unlocked before (the unlocked wallet is still encryped - but the encryption key is in memory).
	Encrypted bool `json:"encrypted,omitempty"`

	// Indicates whether the wallet is currently rescanning the blockchain. This will be true for the duration of calls to /unlock, /seeds, /init/seed, and /sweep/seed.
	Rescanning bool `json:"rescanning,omitempty"`

	// Number of siacoins, in hastings, that can be claimed from the siafunds as of the most recent block. Because the claim balance increases every time a file contract is created, it is possible that the balance will increase before any claim transaction is confirmed.
	Siacoinclaimbalance string `json:"siacoinclaimbalance,omitempty"`

	// Number of siafunds available to the wallet as of the most recent block in the blockchain.
	Siafundbalance string `json:"siafundbalance,omitempty"`

	// Number of siacoins, in hastings, are entering the wallet according to the set of unconfirmed transactions. This number is often inflated by outgoing siacoins, because outputs are frequently larger than the amount being sent. The refund will be included in the unconfirmed incoming siacoins balance.
	Unconfirmedincomingsiacoins string `json:"unconfirmedincomingsiacoins,omitempty"`

	// Number of siacoins, in hastings, that are leaving the wallet according to the set of unconfirmed transactions. Often this number appears inflated, because outputs are frequently larger than the number of coins being sent, and there is a refund. These coins are counted as outgoing, and the refund is counted as incoming. The difference in balance can be calculated using 'unconfirmedincomingsiacoins' - 'unconfirmedoutgoingsiacoins'
	Unconfirmedoutgoingsiacoins string `json:"unconfirmedoutgoingsiacoins,omitempty"`

	// Indicates whether the wallet is currently locked or unlocked. Some calls become unavailable when the wallet is locked.
	Unlocked bool `json:"unlocked,omitempty"`
}

// Validate validates this get wallet o k body
func (o *GetWalletOKBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetWalletOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetWalletOKBody) UnmarshalBinary(b []byte) error {
	var res GetWalletOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
